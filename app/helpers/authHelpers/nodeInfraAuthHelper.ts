import moment from "moment";
var crypto = require("crypto");

export const getKey = (
  url: string,
  nodeType: string,
  address: string
): string => {
  if (
    url.includes("from/" + utils.nodeTypes.generator) ||
    nodeType == utils.nodeTypes.generator
  ) {
    return commonFunctions.findKey(
      address,
      (global as any).environment.generatorNodeApiKeys
    );
  } else if (
    url.includes("from/" + utils.nodeTypes.validator) ||
    nodeType == utils.nodeTypes.validator
  ) {
    return commonFunctions.findKey(
      address,
      (global as any).environment.validatorNodeApiKeys
    );
  } else if (
    url.includes("from/" + utils.nodeTypes.master) ||
    nodeType == utils.nodeTypes.master
  ) {
    return (global as any).environment.masterNodeApiKey;
  } else if (
    url.includes(utils.nodeTypes.fiber) ||
    url.includes(utils.nodeTypes.fiberFeeDistribution)
  ) {
    return (global as any).environment.fiberApiKey;
  }
  return "";
};

export const isTokenValid = (token: any, key: string): boolean => {
  let isValid = false;
  try {
    let decryptedToken = commonFunctions.decrypt(token, key);
    if (decryptedToken) {
      let tokenIntoJsonObject = JSON.parse(decryptedToken);
      if (tokenIntoJsonObject) {
        let isDatesValidate = validateDates(tokenIntoJsonObject);
        if (isDatesValidate) {
          isValid = true;
        }
      }
    }
  } catch (e: any) {
    console.log(e);
    isValid = false;
  }

  return isValid;
};

export const validateDates = (data: any): boolean => {
  try {
    if (data.startDateTime && data.endDateTime) {
      let currentDate = moment().utc();
      let startDate = moment(data.startDateTime).utc();
      let endDate = moment(data.endDateTime).utc();
      return currentDate.isBetween(startDate, endDate);
    }
  } catch (e: any) {
    console.log(e);
  }

  return false;
};

export const createAuthToken = (key: string) => {
  let timelapse = 1;
  let currentTime = new Date();
  let startDateTime = moment(currentTime)
    .subtract("minutes", timelapse)
    .utc()
    .format();
  let endDateTime = moment(currentTime)
    .add("minutes", timelapse)
    .utc()
    .format();
  let randomKey = crypto.randomBytes(512).toString("hex");
  let tokenBody: any = {};
  tokenBody.startDateTime = startDateTime;
  tokenBody.endDateTime = endDateTime;
  tokenBody.randomKey = randomKey;

  let strTokenBody = JSON.stringify(tokenBody);
  let encryptedSessionToken = commonFunctions.encrypt(strTokenBody, key);
  return encryptedSessionToken;
};
